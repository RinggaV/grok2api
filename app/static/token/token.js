var apiKey = '';
var allTokens = {};
var flatTokens = [];
var isBatchProcessing = false;
var isBatchPaused = false;
var batchQueue = [];
var batchTotal = 0;
var batchProcessed = 0;
var currentBatchAction = null;
var BATCH_SIZE = 50;
var autoRegisterJobId = null;
var autoRegisterTimer = null;
var autoRegisterLastAdded = 0;
var liveStatsTimer = null;
var isWorkersRuntime = false;
var isNsfwRefreshAllRunning = false;
var isLoadDataRunning = false;
var pendingLoadData = false;
var isStatsRefreshRunning = false;
var loadDataSeq = 0;
var activeRefreshJob = null;
var refreshJobPollTimer = null;
var lastRefreshJobSnapshot = null;
var refreshJobPollFailures = 0;
var tokenVisibilityHookBound = false;
var failedJobsCleanupDone = false;

const TOKEN_LOAD_TIMEOUT_MS = 20000;
const TOKEN_REFRESH_TIMEOUT_MS = 30000;
const TOKEN_STATS_TIMEOUT_MS = 12000;
const LIVE_STATS_INTERVAL_MS = 10000;
const TOKEN_JOB_POLL_INTERVAL_MS = 650;
const TOKEN_JOB_POLL_RETRY_BASE_MS = 1200;
const TOKEN_JOB_POLL_RETRY_MAX_MS = 6000;
const TOKEN_ACTIVE_JOB_STORAGE_KEY = 'grok2api_token_active_job';
const NSFW_REFRESH_JOB_RETRIES = 2;

var displayTokens = [];
var filterState = {
  typeSso: false,
  typeSuperSso: false,
  statusActive: false,
  statusInvalid: false,
  statusExhausted: false,
};

function logAdminDebug(...args) {
  if (typeof window.adminDebug === 'function') {
    window.adminDebug(...args);
  }
}

function hasTokenDom() {
  return Boolean(document.getElementById('token-table-body'));
}

function withTimeoutSignal(timeoutMs) {
  const ms = Math.max(1000, Number(timeoutMs) || 5000);
  const controller = new AbortController();
  const timer = window.setTimeout(() => controller.abort(), ms);
  return {
    signal: controller.signal,
    done() {
      window.clearTimeout(timer);
    },
  };
}

function normalizeRequestErrorMessage(err, fallback) {
  const msg = String(err?.message || '').trim();
  if (!msg) return fallback;
  if (msg.includes('aborted') || msg.includes('超时')) return '请求超时，请稍后重试';
  return msg;
}

function collectKnownTokenValues() {
  const out = [];
  const seen = new Set();
  flatTokens.forEach((item) => {
    const token = normalizeSsoToken(item?.token || '');
    if (!token || seen.has(token)) return;
    seen.add(token);
    out.push(token);
  });
  return out;
}

function summarizeTokenRefreshResults(payload, fallbackTotal) {
  const results = payload?.results && typeof payload.results === 'object' ? payload.results : {};
  const values = Object.values(results);
  const total = values.length || Math.max(0, Number(fallbackTotal) || 0);
  const success = values.filter((v) => Boolean(v)).length;
  const failed = Math.max(0, total - success);
  return {
    total,
    success,
    failed,
    invalidated: 0,
  };
}

function summarizeFailedItems(payload, maxItems = 3) {
  const failed = Array.isArray(payload?.failed) ? payload.failed : [];
  if (!failed.length) return '';
  const lines = failed.slice(0, Math.max(1, maxItems)).map((it) => {
    const token = String(it?.token || '').trim();
    const shortToken = token.length > 12 ? `${token.slice(0, 4)}...${token.slice(-4)}` : token || '-';
    const step = String(it?.step || 'unknown');
    const error = String(it?.error || '').trim() || '-';
    return `${shortToken} [${step}] ${error}`;
  });
  const more = failed.length > lines.length ? ` 等 ${failed.length} 条` : '';
  return `${lines.join(' | ')}${more}`;
}

function isRefreshJobRunningStatus(status) {
  return status === 'queued' || status === 'running';
}

function parseStoredRefreshJob(raw) {
  if (!raw) return null;
  try {
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') return null;
    const jobId = String(parsed.jobId || '').trim();
    const jobType = String(parsed.jobType || '').trim();
    if (!jobId || !jobType) return null;
    return { jobId, jobType };
  } catch (e) {
    return null;
  }
}

function saveActiveRefreshJob(jobId, jobType) {
  activeRefreshJob = { jobId, jobType };
  try {
    localStorage.setItem(TOKEN_ACTIVE_JOB_STORAGE_KEY, JSON.stringify(activeRefreshJob));
  } catch (e) {}
}

function clearActiveRefreshJob() {
  activeRefreshJob = null;
  lastRefreshJobSnapshot = null;
  try {
    localStorage.removeItem(TOKEN_ACTIVE_JOB_STORAGE_KEY);
  } catch (e) {}
}

function restoreActiveRefreshJob() {
  if (activeRefreshJob && activeRefreshJob.jobId) return activeRefreshJob;
  try {
    const raw = localStorage.getItem(TOKEN_ACTIVE_JOB_STORAGE_KEY);
    activeRefreshJob = parseStoredRefreshJob(raw);
    return activeRefreshJob;
  } catch (e) {
    return null;
  }
}

function updateRefreshJobUi(job, options = {}) {
  const silent = Boolean(options.silent);
  const nsfwBtn = document.getElementById('btn-refresh-nsfw-all');
  if (nsfwBtn) nsfwBtn.disabled = isRefreshJobRunningStatus(String(job?.status || ''));
  const container = document.getElementById('batch-progress');
  const text = document.getElementById('batch-progress-text');
  const pauseBtn = document.getElementById('btn-pause-action');
  const stopBtn = document.getElementById('btn-stop-action');
  if (container && text) {
    const total = Number(job?.total || 0);
    const processed = Number(job?.processed || 0);
    const success = Number(job?.success || 0);
    const failed = Number(job?.failed || 0);
    const step = String(job?.current_step || '').trim();
    const status = String(job?.status || '').trim();
    const updatedAt = Number(job?.updated_at || 0);
    const pct = total > 0 ? Math.min(100, Math.floor((processed / total) * 100)) : 0;
    const parts = [
      `${pct}%`,
      `${processed}/${total}`,
      `成功 ${success}`,
      `失败 ${failed}`,
    ];
    if (status === 'queued') parts.push('排队中');
    if (status === 'running' && step) parts.push(step);
    if (status === 'cancelled') parts.push('已取消');
    if (status === 'failed') parts.push('已失败');
    if (status === 'completed') parts.push('已完成');
    if (updatedAt > 0) {
      const ageSec = Math.max(0, Math.floor((Date.now() - updatedAt) / 1000));
      parts.push(`更新 ${ageSec}s 前`);
    }
    text.textContent = parts.join(' · ');
    container.classList.remove('hidden');
  }
  if (pauseBtn) pauseBtn.classList.add('hidden');
  if (stopBtn) {
    if (isRefreshJobRunningStatus(String(job?.status || ''))) {
      stopBtn.textContent = '取消任务';
      stopBtn.classList.remove('hidden');
    } else {
      stopBtn.classList.add('hidden');
    }
  }
  setActionButtonsState();
  if (!silent) {
    logAdminDebug('token:refreshJob:ui', {
      jobId: job?.job_id || '',
      status: job?.status || '',
      processed: job?.processed || 0,
      total: job?.total || 0,
    });
  }
}

function resetRefreshJobUi() {
  const nsfwBtn = document.getElementById('btn-refresh-nsfw-all');
  if (nsfwBtn) nsfwBtn.disabled = false;
  const container = document.getElementById('batch-progress');
  const text = document.getElementById('batch-progress-text');
  const pauseBtn = document.getElementById('btn-pause-action');
  const stopBtn = document.getElementById('btn-stop-action');
  if (text) text.textContent = '';
  if (container) container.classList.add('hidden');
  if (pauseBtn) pauseBtn.classList.add('hidden');
  if (stopBtn) stopBtn.classList.add('hidden');
  setActionButtonsState();
}

function stopRefreshJobPolling() {
  if (refreshJobPollTimer) clearTimeout(refreshJobPollTimer);
  refreshJobPollTimer = null;
  refreshJobPollFailures = 0;
}

function scheduleRefreshJobPolling(delayMs, options = {}) {
  const silent = Boolean(options.silent);
  if (!hasTokenDom()) return;
  if (refreshJobPollTimer) clearTimeout(refreshJobPollTimer);
  const delay = Math.max(120, Math.floor(Number(delayMs) || TOKEN_JOB_POLL_INTERVAL_MS));
  refreshJobPollTimer = setTimeout(() => {
    pollRefreshJobOnce({ silent });
  }, delay);
}

async function pollRefreshJobOnce(options = {}) {
  const silent = Boolean(options.silent);
  const current = activeRefreshJob || restoreActiveRefreshJob();
  if (!current || !current.jobId) {
    stopRefreshJobPolling();
    resetRefreshJobUi();
    return null;
  }

  try {
    const res = await fetch(`/api/v1/admin/jobs/${encodeURIComponent(current.jobId)}`, {
      headers: buildAuthHeaders(apiKey),
      cache: 'no-store',
    });
    const payload = await parseJsonSafely(res);
    if (res.status === 401) {
      logout();
      return null;
    }
    if (!res.ok) {
      if (res.status === 404) {
        stopRefreshJobPolling();
        clearActiveRefreshJob();
        resetRefreshJobUi();
        if (!silent) showToast('任务不存在或已过期', 'warning');
        return null;
      }
      refreshJobPollFailures += 1;
      const retryDelay = Math.min(
        TOKEN_JOB_POLL_RETRY_MAX_MS,
        TOKEN_JOB_POLL_RETRY_BASE_MS * (refreshJobPollFailures <= 1 ? 1 : Math.pow(2, Math.min(3, refreshJobPollFailures - 1)))
      );
      scheduleRefreshJobPolling(retryDelay, { silent: true });
      if (!silent) {
        showToast(extractApiErrorMessage(payload, '读取任务状态失败'), 'error');
      }
      return null;
    }
    const job = payload?.job || null;
    if (!job) {
      refreshJobPollFailures += 1;
      scheduleRefreshJobPolling(TOKEN_JOB_POLL_RETRY_BASE_MS, { silent: true });
      return null;
    }

    refreshJobPollFailures = 0;
    lastRefreshJobSnapshot = job;
    updateRefreshJobUi(job, { silent });
    if (isRefreshJobRunningStatus(String(job.status || ''))) {
      scheduleRefreshJobPolling(TOKEN_JOB_POLL_INTERVAL_MS, { silent: true });
      return job;
    }

    stopRefreshJobPolling();
    clearActiveRefreshJob();
    const summary = job?.result?.summary || {
      total: Number(job.total || 0),
      success: Number(job.success || 0),
      failed: Number(job.failed || 0),
      invalidated: Number(job.invalidated || 0),
    };
    const total = Number(summary.total || 0);
    const success = Number(summary.success || 0);
    const failed = Number(summary.failed || 0);
    const invalidated = Number(summary.invalidated || 0);
    const failedDetails = summarizeFailedItems(job?.result || {});

    if (job.status === 'completed') {
      showToast(`任务完成：总计 ${total}，成功 ${success}，失败 ${failed}，失效 ${invalidated}`, failed > 0 ? 'info' : 'success');
      if (failedDetails) showToast(`失败详情: ${failedDetails}`, 'warning');
    } else if (job.status === 'cancelled') {
      showToast('任务已取消', 'info');
    } else if (job.status === 'failed') {
      const msg = String(job.last_error || '').trim() || '任务执行失败';
      showToast(msg, 'error');
      if (failedDetails) showToast(`失败详情: ${failedDetails}`, 'warning');
    }
    if (hasTokenDom()) {
      loadData();
      resetRefreshJobUi();
    }
    return job;
  } catch (e) {
    refreshJobPollFailures += 1;
    const retryDelay = Math.min(
      TOKEN_JOB_POLL_RETRY_MAX_MS,
      TOKEN_JOB_POLL_RETRY_BASE_MS * (refreshJobPollFailures <= 1 ? 1 : Math.pow(2, Math.min(3, refreshJobPollFailures - 1)))
    );
    scheduleRefreshJobPolling(retryDelay, { silent: true });
    if (!silent) {
      showToast(`读取任务状态失败: ${normalizeRequestErrorMessage(e, '请求失败')}`, 'error');
    }
    return null;
  }
}

async function startRefreshJob(endpoint, body, jobType, options = {}) {
  const silent = Boolean(options.silent);
  const current = activeRefreshJob || restoreActiveRefreshJob();
  if (current && current.jobId) {
    if (!silent) showToast('当前已有刷新任务在执行', 'info');
    return false;
  }
  const timed = withTimeoutSignal(TOKEN_REFRESH_TIMEOUT_MS);
  try {
    const res = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...buildAuthHeaders(apiKey),
      },
      body: JSON.stringify(body || {}),
      signal: timed.signal,
    });
    const payload = await parseJsonSafely(res);
    if (res.status === 401) {
      logout();
      return false;
    }
    if (!res.ok) {
      if (!silent) showToast(extractApiErrorMessage(payload, '启动任务失败'), 'error');
      return false;
    }
    const jobId = String(payload?.job_id || '').trim();
    if (!jobId) {
      if (!silent) showToast('启动任务失败：缺少任务 ID', 'error');
      return false;
    }
    saveActiveRefreshJob(jobId, jobType);
    stopRefreshJobPolling();
    await pollRefreshJobOnce({ silent: true });
    if (!silent) {
      const reused = Boolean(payload?.reused);
      showToast(reused ? '已恢复正在执行的任务' : '任务已启动，可切换 Tab 后继续执行', 'success');
    }
    return true;
  } catch (e) {
    if (!silent) {
      showToast(`启动任务失败: ${normalizeRequestErrorMessage(e, '请求失败')}`, 'error');
    }
    return false;
  } finally {
    timed.done();
  }
}

async function cancelActiveRefreshJob() {
  const current = activeRefreshJob || restoreActiveRefreshJob();
  if (!current || !current.jobId) return;
  const timed = withTimeoutSignal(TOKEN_REFRESH_TIMEOUT_MS);
  try {
    const res = await fetch(`/api/v1/admin/jobs/${encodeURIComponent(current.jobId)}/cancel`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...buildAuthHeaders(apiKey),
      },
      body: JSON.stringify({ purge: true }),
      signal: timed.signal,
    });
    const payload = await parseJsonSafely(res);
    if (res.status === 401) {
      logout();
      return;
    }
    if (!res.ok) {
      showToast(extractApiErrorMessage(payload, '取消任务失败'), 'error');
      return;
    }
    const deleted = Boolean(payload?.deleted);
    if (deleted) {
      stopRefreshJobPolling();
      clearActiveRefreshJob();
      resetRefreshJobUi();
      if (hasTokenDom()) loadData();
      showToast('任务已取消并清理', 'success');
      return;
    }
    showToast('已发送取消请求', 'info');
  } catch (e) {
    showToast(`取消任务失败: ${normalizeRequestErrorMessage(e, '请求失败')}`, 'error');
  } finally {
    timed.done();
  }
}

function createNsfwProgressController(btn, originalText, estimatedTotal) {
  let stage = '请求中';
  const startedAt = Date.now();
  const total = Math.max(0, Number(estimatedTotal) || 0);
  const update = () => {
    if (!btn) return;
    const sec = Math.max(0, Math.floor((Date.now() - startedAt) / 1000));
    const totalText = total > 0 ? ` / 约${total}个` : '';
    btn.innerHTML = `${stage} (${sec}s${totalText})`;
  };
  update();
  const timer = setInterval(update, 500);
  return {
    setStage(next) {
      stage = String(next || stage);
      update();
    },
    stop() {
      clearInterval(timer);
      if (btn) btn.innerHTML = originalText || '一键刷新 NSFW';
    },
  };
}

function logNsfwDebug(event, data) {
  logAdminDebug(`token:nsfw:${event}`, data || {});
  try {
    if (data !== undefined) console.info(`[NSFW] ${event}`, data);
    else console.info(`[NSFW] ${event}`);
  } catch (e) {}
}

function chunkArray(items, size) {
  const out = [];
  const list = Array.isArray(items) ? items : [];
  const chunkSize = Math.max(1, Math.floor(Number(size) || 1));
  for (let i = 0; i < list.length; i += chunkSize) {
    out.push(list.slice(i, i + chunkSize));
  }
  return out;
}

function normalizeSsoToken(token) {
  const v = String(token || '').trim();
  return v.startsWith('sso=') ? v.slice(4).trim() : v;
}

function poolToType(pool) {
  return String(pool || '').trim() === 'ssoSuper' ? 'ssoSuper' : 'sso';
}

function normalizeStatus(rawStatus) {
  const status = String(rawStatus || 'active').trim().toLowerCase();
  if (status === 'expired') return 'invalid';
  if (status === 'active' || status === 'cooling' || status === 'invalid' || status === 'disabled') return status;
  return 'active';
}

function parseQuotaValue(v) {
  if (v === null || v === undefined || v === '') return { value: -1, known: false };
  const n = Number(v);
  if (!Number.isFinite(n) || n < 0) return { value: -1, known: false };
  return { value: Math.floor(n), known: true };
}

function extractApiErrorMessage(payload, fallback = '请求失败') {
  if (!payload) return fallback;
  if (typeof payload === 'string' && payload.trim()) return payload.trim();
  if (typeof payload.detail === 'string' && payload.detail.trim()) return payload.detail.trim();
  if (typeof payload.error === 'string' && payload.error.trim()) return payload.error.trim();
  if (typeof payload.message === 'string' && payload.message.trim()) return payload.message.trim();
  if (payload.error && typeof payload.error.message === 'string' && payload.error.message.trim()) {
    return payload.error.message.trim();
  }
  return fallback;
}

async function parseJsonSafely(response) {
  try {
    return await response.json();
  } catch (e) {
    return null;
  }
}

async function cleanupFailedJobs(options = {}) {
  const silent = Boolean(options.silent);
  const force = Boolean(options.force);
  if (failedJobsCleanupDone && !force) return 0;
  if (!apiKey) return 0;
  const btn = document.getElementById('btn-cleanup-failed-jobs');
  if (btn) btn.disabled = true;
  const timed = withTimeoutSignal(10000);
  try {
    const res = await fetch('/api/v1/admin/jobs/cleanup', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...buildAuthHeaders(apiKey),
      },
      body: JSON.stringify({ statuses: ['failed', 'cancelled', 'completed'] }),
      signal: timed.signal,
    });
    const payload = await parseJsonSafely(res);
    if (res.status === 401) {
      logout();
      return 0;
    }
    if (!res.ok || payload?.status === 'error') {
      const message = extractApiErrorMessage(payload, `HTTP ${res.status}`);
      if (!silent) showToast(`清理失败任务失败: ${message}`, 'error');
      return 0;
    }
    const deleted = Number(payload?.deleted ?? payload?.result?.deleted ?? 0);
    failedJobsCleanupDone = true;
    if (!silent) {
      if (deleted > 0) showToast(`已清理 ${deleted} 条失败任务`, 'success');
      else showToast('暂无失败任务需要清理', 'info');
    }
    if (deleted > 0 && hasTokenDom() && !silent) {
      loadData();
    }
    return deleted;
  } catch (e) {
    if (!silent) showToast(`清理失败任务失败: ${normalizeRequestErrorMessage(e, '请求失败')}`, 'error');
    return 0;
  } finally {
    timed.done();
    if (btn) btn.disabled = false;
  }
}

window.cleanupFailedJobs = cleanupFailedJobs;

async function cleanupStaleJobs(options = {}) {
  const silent = Boolean(options.silent);
  const staleMinutes = Math.max(1, Number(options.stale_minutes || 15));
  if (!apiKey) return 0;
  const btn = document.getElementById('btn-cleanup-stale-jobs');
  if (btn) btn.disabled = true;
  const timed = withTimeoutSignal(15000);
  try {
    const res = await fetch('/api/v1/admin/jobs/cleanup-stale', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...buildAuthHeaders(apiKey),
      },
      body: JSON.stringify({
        stale_minutes: staleMinutes,
        statuses: ['queued', 'running'],
      }),
      signal: timed.signal,
    });
    const payload = await parseJsonSafely(res);
    if (res.status === 401) {
      logout();
      return 0;
    }
    if (!res.ok || payload?.status === 'error') {
      const message = extractApiErrorMessage(payload, `HTTP ${res.status}`);
      if (!silent) showToast(`清理卡死任务失败: ${message}`, 'error');
      return 0;
    }
    const deleted = Number(payload?.deleted ?? payload?.result?.deleted ?? 0);
    if (!silent) {
      if (deleted > 0) showToast(`已清理 ${deleted} 条卡死任务`, 'success');
      else showToast('暂无卡死任务需要清理', 'info');
    }
    if (deleted > 0) {
      stopRefreshJobPolling();
      clearActiveRefreshJob();
      resetRefreshJobUi();
      if (hasTokenDom()) loadData();
    }
    return deleted;
  } catch (e) {
    if (!silent) showToast(`清理卡死任务失败: ${normalizeRequestErrorMessage(e, '请求失败')}`, 'error');
    return 0;
  } finally {
    timed.done();
    if (btn) btn.disabled = false;
  }
}

window.cleanupStaleJobs = cleanupStaleJobs;

function normalizeTokenRecord(pool, raw) {
  const tokenType = poolToType(pool);
  const isString = typeof raw === 'string';
  const source = isString ? { token: raw } : (raw || {});
  const token = normalizeSsoToken(source.token);
  if (!token) return null;

  const status = normalizeStatus(source.status);
  const quotaParsed = parseQuotaValue(source.quota);
  const heavyParsed = parseQuotaValue(source.heavy_quota);

  return {
    token,
    status,
    quota: quotaParsed.known ? quotaParsed.value : 0,
    quota_known: quotaParsed.known,
    heavy_quota: heavyParsed.known ? heavyParsed.value : -1,
    heavy_quota_known: heavyParsed.known,
    token_type: source.token_type || tokenType,
    note: source.note || '',
    fail_count: source.fail_count || 0,
    use_count: source.use_count || 0,
    pool: pool,
    _selected: false,
  };
}

function isTokenInvalid(item) {
  return ['invalid', 'expired', 'disabled'].includes(String(item.status || '').toLowerCase());
}

function isTokenExhausted(item) {
  const status = String(item.status || '').toLowerCase();
  if (status === 'cooling') return true;
  if (Boolean(item.quota_known) && Number(item.quota) <= 0) return true;
  const tokenType = String(item.token_type || poolToType(item.pool));
  if (tokenType === 'ssoSuper' && Boolean(item.heavy_quota_known) && Number(item.heavy_quota) <= 0) return true;
  return false;
}

function isTokenActive(item) {
  return !isTokenInvalid(item) && !isTokenExhausted(item);
}

function getTokenKey(token) {
  return normalizeSsoToken(token);
}

function findTokenIndexByKey(tokenKey) {
  const key = getTokenKey(tokenKey);
  return flatTokens.findIndex((t) => getTokenKey(t.token) === key);
}

function refreshFilterStateFromDom() {
  const getChecked = (id) => {
    const el = document.getElementById(id);
    return Boolean(el && el.checked);
  };
  filterState.typeSso = getChecked('filter-type-sso');
  filterState.typeSuperSso = getChecked('filter-type-supersso');
  filterState.statusActive = getChecked('filter-status-active');
  filterState.statusInvalid = getChecked('filter-status-invalid');
  filterState.statusExhausted = getChecked('filter-status-exhausted');
}

function applyFilters() {
  refreshFilterStateFromDom();

  const hasTypeFilter = filterState.typeSso || filterState.typeSuperSso;
  const hasStatusFilter = filterState.statusActive || filterState.statusInvalid || filterState.statusExhausted;

  displayTokens = flatTokens.filter((item) => {
    const tokenType = String(item.token_type || poolToType(item.pool));
    const matchesType = !hasTypeFilter
      || (filterState.typeSso && tokenType === 'sso')
      || (filterState.typeSuperSso && tokenType === 'ssoSuper');

    if (!matchesType) return false;
    if (!hasStatusFilter) return true;

    const active = isTokenActive(item);
    const invalid = isTokenInvalid(item);
    const exhausted = isTokenExhausted(item);
    return (filterState.statusActive && active)
      || (filterState.statusInvalid && invalid)
      || (filterState.statusExhausted && exhausted);
  });

  const resultEl = document.getElementById('filter-result-count');
  if (resultEl) {
    resultEl.textContent = String(displayTokens.length);
  }
}

function onFilterChange() {
  applyFilters();
  renderTable();
}

function resetFilters() {
  ['filter-type-sso', 'filter-type-supersso', 'filter-status-active', 'filter-status-invalid', 'filter-status-exhausted']
    .forEach((id) => {
      const el = document.getElementById(id);
      if (el) el.checked = false;
    });
  applyFilters();
  renderTable();
}

function setAutoRegisterUiEnabled(enabled) {
  const btnAuto = document.getElementById('tab-btn-auto');
  const tabAuto = document.getElementById('add-tab-auto');
  if (btnAuto) btnAuto.style.display = enabled ? '' : 'none';
  if (tabAuto) tabAuto.style.display = enabled ? '' : 'none';
  if (!enabled) {
    try {
      switchAddTab('manual');
    } catch (e) {
      // ignore
    }
  }
}

function setNsfwRefreshUiEnabled(enabled) {
  const btn = document.getElementById('btn-refresh-nsfw-all');
  if (!btn) return;
  if (enabled) {
    btn.classList.remove('hidden');
  } else {
    btn.classList.add('hidden');
  }
}

function ensureTokenPageControlsVisible() {
  const batchActions = document.getElementById('batch-actions');
  if (batchActions) batchActions.classList.remove('hidden');
  setNsfwRefreshUiEnabled(true);
}

async function detectWorkersRuntime() {
  try {
    const res = await fetch('/health', { cache: 'no-store' });
    if (!res.ok) return false;
    const text = await res.text();
    try {
      const data = JSON.parse(text);
      const runtime = (data && data.runtime) ? String(data.runtime) : '';
      return runtime.toLowerCase() === 'cloudflare-workers';
    } catch (e) {
      return /cloudflare-workers/i.test(text);
    }
  } catch (e) {
    return false;
  }
}

async function applyRuntimeUiFlags() {
  // NSFW refresh is a server API capability; keep it visible by default.
  setNsfwRefreshUiEnabled(true);
  // Auto-register still depends on runtime capability.
  setAutoRegisterUiEnabled(false);
  isWorkersRuntime = await detectWorkersRuntime();
  if (!isWorkersRuntime) {
    setAutoRegisterUiEnabled(true);
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', applyRuntimeUiFlags);
} else {
  applyRuntimeUiFlags();
}

async function init() {
  logAdminDebug('token:init:start');
  if (!hasTokenDom()) {
    logAdminDebug('token:init:skip-no-dom');
    return;
  }
  ensureTokenPageControlsVisible();
  applyRuntimeUiFlags().catch(() => {});
  apiKey = await ensureApiKey();
  if (apiKey === null) {
    logAdminDebug('token:init:no-key');
    return;
  }
  await cleanupFailedJobs({ silent: true });
  logAdminDebug('token:init:ready');
  setupConfirmDialog();
  loadData();
  startLiveStats();
  const storedJob = restoreActiveRefreshJob();
  if (storedJob && storedJob.jobId) {
    pollRefreshJobOnce({ silent: true });
  } else {
    resetRefreshJobUi();
  }
  if (!tokenVisibilityHookBound) {
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState !== 'visible') return;
      if (!hasTokenDom()) return;
      const job = activeRefreshJob || restoreActiveRefreshJob();
      if (job && job.jobId) {
        pollRefreshJobOnce({ silent: true });
      }
    });
    tokenVisibilityHookBound = true;
  }
}

function startLiveStats() {
  if (liveStatsTimer) clearInterval(liveStatsTimer);
  // Keep stats fresh (use_count / quota changes) without disrupting table interactions.
  liveStatsTimer = setInterval(() => {
    refreshStatsOnly();
  }, LIVE_STATS_INTERVAL_MS);
}

function cleanup() {
  logAdminDebug('token:cleanup');
  if (liveStatsTimer) clearInterval(liveStatsTimer);
  liveStatsTimer = null;
  stopRefreshJobPolling();
}

function registerPage() {
  const registry = window.__pageRegistry || (window.__pageRegistry = {});
  const pageInit = init;
  const pageCleanup = cleanup;
  registry.token = {
    init: pageInit,
    cleanup: pageCleanup,
  };
}

registerPage();

async function refreshStatsOnly() {
  if (isStatsRefreshRunning) return;
  isStatsRefreshRunning = true;
  const timed = withTimeoutSignal(TOKEN_STATS_TIMEOUT_MS);
  try {
    const res = await fetch('/api/v1/admin/tokens', {
      headers: buildAuthHeaders(apiKey),
      signal: timed.signal,
    });
    if (res.status === 401) {
      logout();
      return;
    }
    if (!res.ok) return;
    const data = await res.json();

    // Recalculate stats without re-rendering table.
    let totalTokens = 0;
    let activeTokens = 0;
    let coolingTokens = 0;
    let invalidTokens = 0;
    let chatQuota = 0;
    let totalCalls = 0;

    Object.keys(data || {}).forEach(pool => {
      const tokens = data[pool];
      if (!Array.isArray(tokens)) return;
      tokens.forEach(t => {
        const row = normalizeTokenRecord(pool, t);
        if (!row) return;
        totalTokens += 1;
        const useCount = Number(row.use_count || 0) || 0;
        totalCalls += useCount;
        if (isTokenInvalid(row)) {
          invalidTokens += 1;
        } else if (isTokenExhausted(row)) {
          coolingTokens += 1;
        } else {
          activeTokens += 1;
          if (Boolean(row.quota_known) && Number(row.quota) > 0) {
            chatQuota += Number(row.quota);
          }
        }
      });
    });

    const imageQuota = Math.floor(chatQuota / 2);

    const setText = (id, text) => {
      const el = document.getElementById(id);
      if (el) el.innerText = text;
    };
    setText('stat-total', totalTokens.toLocaleString());
    setText('stat-active', activeTokens.toLocaleString());
    setText('stat-cooling', coolingTokens.toLocaleString());
    setText('stat-invalid', invalidTokens.toLocaleString());
    setText('stat-chat-quota', chatQuota.toLocaleString());
    setText('stat-image-quota', imageQuota.toLocaleString());
    setText('stat-total-calls', totalCalls.toLocaleString());
  } catch (e) {
    logAdminDebug('token:refreshStatsOnly:error', { message: e?.message || String(e) });
    // Silent by design; do not spam toasts.
  } finally {
    timed.done();
    isStatsRefreshRunning = false;
  }
}

async function loadData() {
  if (isLoadDataRunning) {
    pendingLoadData = true;
    return;
  }
  isLoadDataRunning = true;
  const requestSeq = ++loadDataSeq;
  const timed = withTimeoutSignal(TOKEN_LOAD_TIMEOUT_MS);
  try {
    logAdminDebug('token:loadData:start');
    const { data, fromCache } = await fetchAdminJsonCached('tokens', '/api/v1/admin/tokens', {
      headers: buildAuthHeaders(apiKey),
      signal: timed.signal,
    });
    if (requestSeq !== loadDataSeq) return;
    if (!hasTokenDom()) {
      logAdminDebug('token:loadData:skip-no-dom');
      return;
    }
    allTokens = data || {};
    processTokens(allTokens);
    updateStats(allTokens);
    applyFilters();
    renderTable();
    logAdminDebug('token:loadData:ok', {
      pools: Object.keys(allTokens || {}).length,
      total: flatTokens.length,
      fromCache: Boolean(fromCache),
    });
  } catch (e) {
    if (String(e?.message || '').includes('401')) logout();
    logAdminDebug('token:loadData:error', { message: e?.message || String(e) });
    if (!hasTokenDom()) return;
    showToast('加载失败: ' + normalizeRequestErrorMessage(e, '请求失败'), 'error');
  } finally {
    timed.done();
    isLoadDataRunning = false;
    if (pendingLoadData) {
      pendingLoadData = false;
      setTimeout(() => loadData(), 60);
    }
  }
}

// Convert pool dict to flattened array
function processTokens(data) {
  const prevSelected = new Set(flatTokens.filter(t => t._selected).map(t => getTokenKey(t.token)));
  flatTokens = [];
  const seen = new Set();

  Object.keys(data || {}).forEach(pool => {
    const tokens = data[pool];
    if (!Array.isArray(tokens)) return;

    tokens.forEach(t => {
      const row = normalizeTokenRecord(pool, t);
      if (!row) return;
      const dedupeKey = `${pool}:${getTokenKey(row.token)}`;
      if (seen.has(dedupeKey)) return;
      seen.add(dedupeKey);
      row._selected = prevSelected.has(getTokenKey(row.token));
      flatTokens.push(row);
    });
  });
}

function updateStats(data) {
  let totalTokens = flatTokens.length;
  let activeTokens = 0;
  let coolingTokens = 0;
  let invalidTokens = 0;
  let chatQuota = 0;
  let totalCalls = 0;

  flatTokens.forEach(t => {
    if (isTokenInvalid(t)) {
      invalidTokens++;
    } else if (isTokenExhausted(t)) {
      coolingTokens++;
    } else {
      activeTokens++;
      if (Boolean(t.quota_known) && Number(t.quota) > 0) {
        chatQuota += Number(t.quota);
      }
    }
    totalCalls += Number(t.use_count || 0);
  });

  const imageQuota = Math.floor(chatQuota / 2);

  const setText = (id, text) => {
    const el = document.getElementById(id);
    if (el) el.innerText = text;
  };

  setText('stat-total', totalTokens.toLocaleString());
  setText('stat-active', activeTokens.toLocaleString());
  setText('stat-cooling', coolingTokens.toLocaleString());
  setText('stat-invalid', invalidTokens.toLocaleString());

  setText('stat-chat-quota', chatQuota.toLocaleString());
  setText('stat-image-quota', imageQuota.toLocaleString());
  setText('stat-total-calls', totalCalls.toLocaleString());
}

function renderTable() {
  const tbody = document.getElementById('token-table-body');
  const loading = document.getElementById('loading');
  const emptyState = document.getElementById('empty-state');

  if (!tbody || !loading || !emptyState) {
    logAdminDebug('token:renderTable:missing-dom', {
      hasBody: Boolean(tbody),
      hasLoading: Boolean(loading),
      hasEmpty: Boolean(emptyState),
    });
    return;
  }

  tbody.innerHTML = '';
  loading.classList.add('hidden');

  if (flatTokens.length === 0) {
    emptyState.innerText = '暂无 Token，请点击右上角导入或添加。';
    emptyState.classList.remove('hidden');
    return;
  }
  if (displayTokens.length === 0) {
    emptyState.innerText = '当前筛选无结果。';
    emptyState.classList.remove('hidden');
    updateSelectionState();
    return;
  }
  emptyState.innerText = '暂无 Token，请点击右上角导入或添加。';
  emptyState.classList.add('hidden');

  displayTokens.forEach((item) => {
    const tr = document.createElement('tr');
    const tokenKey = getTokenKey(item.token);
    const tokenEncoded = encodeURIComponent(item.token);
    const tokenKeyEncoded = encodeURIComponent(tokenKey);

    // Checkbox (Center)
    const tdCheck = document.createElement('td');
    tdCheck.className = 'text-center';
    tdCheck.innerHTML = `<input type="checkbox" class="checkbox" ${item._selected ? 'checked' : ''} onchange="toggleSelectByKey(decodeURIComponent('${tokenKeyEncoded}'))">`;

    // Token (Left)
    const tdToken = document.createElement('td');
    tdToken.className = 'text-left';
    const tokenShort = item.token.length > 24
      ? item.token.substring(0, 8) + '...' + item.token.substring(item.token.length - 16)
      : item.token;
    tdToken.innerHTML = `
                <div class="flex items-center gap-2">
                    <span class="font-mono text-xs text-gray-500" title="${item.token}">${tokenShort}</span>
                    <button class="text-gray-400 hover:text-black transition-colors" onclick="copyToClipboard(decodeURIComponent('${tokenEncoded}'), this)">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                    </button>
                </div>
             `;

    // Type (Center)
    const tdType = document.createElement('td');
    tdType.className = 'text-center';
    tdType.innerHTML = `<span class="badge badge-gray">${escapeHtml(item.pool)}</span>`;

    // Status (Center)
    const tdStatus = document.createElement('td');
    let statusClass = 'badge-gray';
    if (isTokenActive(item)) statusClass = 'badge-green';
    else if (isTokenExhausted(item)) statusClass = 'badge-orange';
    else statusClass = 'badge-red';
    tdStatus.className = 'text-center';
    tdStatus.innerHTML = `<span class="badge ${statusClass}">${isTokenActive(item) ? 'active' : (isTokenExhausted(item) ? 'exhausted' : 'invalid')}</span>`;

    // Quota (Center)
    const tdQuota = document.createElement('td');
    tdQuota.className = 'text-center font-mono text-xs';
    tdQuota.innerText = item.quota_known ? String(item.quota) : '-';

    // Note (Left)
    const tdNote = document.createElement('td');
    tdNote.className = 'text-left text-gray-500 text-xs truncate max-w-[150px]';
    tdNote.innerText = item.note || '-';

    // Actions (Center)
    const tdActions = document.createElement('td');
    tdActions.className = 'text-center';
    tdActions.innerHTML = `
                <div class="flex items-center justify-center gap-2">
                     <button onclick="refreshStatus(decodeURIComponent('${tokenEncoded}'), this)" class="p-1 text-gray-400 hover:text-black rounded" title="刷新状态">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
                     </button>
                     <button onclick="openEditModalByKey(decodeURIComponent('${tokenKeyEncoded}'))" class="p-1 text-gray-400 hover:text-black rounded" title="编辑">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                     </button>
                     <button onclick="deleteTokenByKey(decodeURIComponent('${tokenKeyEncoded}'))" class="p-1 text-gray-400 hover:text-red-600 rounded" title="删除">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                     </button>
                </div>
             `;

    tr.appendChild(tdCheck);
    tr.appendChild(tdToken);
    tr.appendChild(tdType);
    tr.appendChild(tdStatus);
    tr.appendChild(tdQuota);
    tr.appendChild(tdNote);
    tr.appendChild(tdActions);

    tbody.appendChild(tr);
  });

  updateSelectionState();
}

// Selection Logic
function toggleSelectAll() {
  const checkbox = document.getElementById('select-all');
  const checked = checkbox.checked;
  const visibleKeys = new Set(displayTokens.map((t) => getTokenKey(t.token)));
  flatTokens.forEach((t) => {
    if (visibleKeys.has(getTokenKey(t.token))) {
      t._selected = checked;
    }
  });
  renderTable();
}

function toggleSelectByKey(tokenKey) {
  const idx = findTokenIndexByKey(tokenKey);
  if (idx < 0) return;
  flatTokens[idx]._selected = !flatTokens[idx]._selected;
  updateSelectionState();
}

function updateSelectionState() {
  const selectedCount = flatTokens.filter(t => t._selected).length;
  const allSelected = displayTokens.length > 0 && displayTokens.every((t) => t._selected);

  const selectAll = document.getElementById('select-all');
  const selectedCountEl = document.getElementById('selected-count');
  if (selectAll) selectAll.checked = allSelected;
  if (selectedCountEl) {
    selectedCountEl.innerText = String(selectedCount);
  } else {
    logAdminDebug('token:updateSelectionState:missing-selected-count');
  }
  setActionButtonsState();
}

// Actions
function addToken() {
  openAddModal();
}

// Batch export (Selected only)
function batchExport() {
  const selected = flatTokens.filter(t => t._selected);
  if (selected.length === 0) return showToast('未选择 Token', 'error');
  let content = "";
  selected.forEach(t => content += t.token + "\n");
  const blob = new Blob([content], { type: 'text/plain' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `tokens_export_selected_${new Date().toISOString().slice(0, 10)}.txt`;
  document.body.appendChild(a);
  a.click();
  window.URL.revokeObjectURL(url);
  document.body.removeChild(a);
}


// Add Modal
function openAddModal() {
  const modal = document.getElementById('add-modal');
  if (!modal) return;
  switchAddTab('manual');
  modal.classList.remove('hidden');
  requestAnimationFrame(() => {
    modal.classList.add('is-open');
  });
}

function closeAddModal() {
  const modal = document.getElementById('add-modal');
  if (!modal) return;
  modal.classList.remove('is-open');
  setTimeout(() => {
    modal.classList.add('hidden');
    resetAddModal();
  }, 200);
}

function resetAddModal() {
  const tokenInput = document.getElementById('add-token-input');
  const noteInput = document.getElementById('add-token-note');
  const quotaInput = document.getElementById('add-token-quota');
  const countInput = document.getElementById('auto-register-count');
  const concurrencyInput = document.getElementById('auto-register-concurrency');
  const statusEl = document.getElementById('auto-register-status');
  const autoBtn = document.getElementById('auto-register-btn');
  if (tokenInput) tokenInput.value = '';
  if (noteInput) noteInput.value = '';
  if (quotaInput) quotaInput.value = 80;
  if (countInput) countInput.value = '';
  if (concurrencyInput) concurrencyInput.value = 10;
  if (statusEl) {
    statusEl.classList.add('hidden');
    statusEl.textContent = '';
  }
  if (autoBtn) autoBtn.disabled = false;
  stopAutoRegisterPolling();
}

function switchAddTab(tab) {
  const manual = document.getElementById('add-tab-manual');
  const auto = document.getElementById('add-tab-auto');
  const btnManual = document.getElementById('tab-btn-manual');
  const btnAuto = document.getElementById('tab-btn-auto');
  if (!manual || !auto || !btnManual || !btnAuto) return;

  if (tab === 'auto') {
    manual.classList.add('hidden');
    auto.classList.remove('hidden');
    btnManual.classList.remove('active');
    btnAuto.classList.add('active');
  } else {
    auto.classList.add('hidden');
    manual.classList.remove('hidden');
    btnAuto.classList.remove('active');
    btnManual.classList.add('active');
  }
}

async function submitManualAdd() {
  const tokenInput = document.getElementById('add-token-input');
  const poolSelect = document.getElementById('add-token-pool');
  const quotaInput = document.getElementById('add-token-quota');
  const noteInput = document.getElementById('add-token-note');

  if (!tokenInput) return;
  let token = normalizeSsoToken(tokenInput.value.trim());
  if (!token) return showToast('Token 不能为空', 'error');

  if (flatTokens.some(t => getTokenKey(t.token) === token)) {
    return showToast('Token 已存在', 'error');
  }

  const pool = poolSelect ? (poolSelect.value.trim() || 'ssoBasic') : 'ssoBasic';
  let quota = quotaInput ? parseInt(quotaInput.value, 10) : 80;
  if (!quota || Number.isNaN(quota)) quota = 80;
  const note = noteInput ? noteInput.value.trim().slice(0, 50) : '';

  flatTokens.push({
    token: token,
    pool: pool,
    quota: quota,
    quota_known: true,
    heavy_quota: -1,
    heavy_quota_known: false,
    token_type: poolToType(pool),
    note: note,
    status: 'active',
    use_count: 0,
    _selected: false
  });

  await syncToServer();
  closeAddModal();
  applyFilters();
  loadData();
}

function stopAutoRegisterPolling() {
  if (autoRegisterTimer) {
    clearInterval(autoRegisterTimer);
    autoRegisterTimer = null;
  }
  autoRegisterJobId = null;
  autoRegisterLastAdded = 0;
  updateAutoRegisterLogs([]);

  const stopBtn = document.getElementById('auto-register-stop-btn');
  if (stopBtn) {
    stopBtn.classList.add('hidden');
    stopBtn.disabled = false;
  }
}

function updateAutoRegisterStatus(text) {
  const statusEl = document.getElementById('auto-register-status');
  if (!statusEl) return;
  statusEl.textContent = text;
  statusEl.classList.remove('hidden');
}

function updateAutoRegisterLogs(lines) {
  const el = document.getElementById('auto-register-logs');
  if (!el) return;
  const arr = Array.isArray(lines) ? lines : [];
  const text = arr.filter(x => typeof x === 'string').join('\n');
  if (!text) {
    el.textContent = '';
    el.classList.add('hidden');
    return;
  }
  el.textContent = text;
  el.classList.remove('hidden');
}

async function startAutoRegister() {
  const btn = document.getElementById('auto-register-btn');
  if (btn) btn.disabled = true;

  try {
    const countEl = document.getElementById('auto-register-count');
    const concurrencyEl = document.getElementById('auto-register-concurrency');

    const pool = 'ssoBasic';
    let countVal = countEl ? parseInt(countEl.value, 10) : NaN;
    if (!countVal || Number.isNaN(countVal) || countVal <= 0) countVal = null;

    let concurrencyVal = concurrencyEl ? parseInt(concurrencyEl.value, 10) : NaN;
    if (!concurrencyVal || Number.isNaN(concurrencyVal) || concurrencyVal <= 0) concurrencyVal = null;

    const res = await fetch('/api/v1/admin/tokens/auto-register', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...buildAuthHeaders(apiKey)
      },
      body: JSON.stringify({ count: countVal, pool: pool, concurrency: concurrencyVal })
    });

    if (!res.ok) {
      const err = await parseJsonSafely(res);
      showToast(extractApiErrorMessage(err, '启动失败'), 'error');
      if (btn) btn.disabled = false;
      return;
    }

    const data = await res.json();
    autoRegisterJobId = data.job?.job_id || null;
    autoRegisterLastAdded = 0;
    updateAutoRegisterStatus('正在启动注册...');
    updateAutoRegisterLogs(data.job?.logs || []);

    const stopBtn = document.getElementById('auto-register-stop-btn');
    if (stopBtn) {
      stopBtn.classList.remove('hidden');
      stopBtn.disabled = false;
    }

    autoRegisterTimer = setInterval(pollAutoRegisterStatus, 2000);
    pollAutoRegisterStatus();
  } catch (e) {
    showToast('启动失败: ' + e.message, 'error');
    if (btn) btn.disabled = false;
  }
}

async function stopAutoRegister() {
  const stopBtn = document.getElementById('auto-register-stop-btn');
  if (stopBtn) stopBtn.disabled = true;

  try {
    if (!autoRegisterJobId) {
      updateAutoRegisterStatus('当前没有进行中的注册任务');
      return;
    }

    const res = await fetch(`/api/v1/admin/tokens/auto-register/stop?job_id=${autoRegisterJobId}`, {
      method: 'POST',
      headers: buildAuthHeaders(apiKey)
    });

    if (!res.ok) {
      const err = await parseJsonSafely(res);
      showToast(extractApiErrorMessage(err, '停止失败'), 'error');
      return;
    }

    updateAutoRegisterStatus('正在停止...');
  } catch (e) {
    showToast('停止失败: ' + e.message, 'error');
  } finally {
    if (stopBtn) stopBtn.disabled = false;
  }
}

async function pollAutoRegisterStatus() {
  if (!autoRegisterJobId) return;
  try {
    const res = await fetch(`/api/v1/admin/tokens/auto-register/status?job_id=${autoRegisterJobId}`, {
      headers: buildAuthHeaders(apiKey)
    });
    if (!res.ok) {
      if (res.status === 401) {
        logout();
        return;
      }
      if (res.status === 404) {
        updateAutoRegisterStatus('注册任务不存在（可能已结束或服务已重启）');
        stopAutoRegisterPolling();
        const btn = document.getElementById('auto-register-btn');
        if (btn) btn.disabled = false;
        return;
      }
      return;
    }

    const data = await res.json();
    updateAutoRegisterLogs(data.logs || []);
    const status = data.status;
    if (status === 'idle' || status === 'not_found') {
      updateAutoRegisterStatus('注册任务已结束');
      stopAutoRegisterPolling();
      const btn = document.getElementById('auto-register-btn');
      if (btn) btn.disabled = false;
      return;
    }
    if (status === 'running' || status === 'starting' || status === 'stopping') {
      const stopBtn = document.getElementById('auto-register-stop-btn');
      if (stopBtn) stopBtn.classList.remove('hidden');

      const completed = data.completed || 0;
      const total = data.total || 0;
      const added = data.added || 0;
      const errors = data.errors || 0;

      if (added > autoRegisterLastAdded) {
        autoRegisterLastAdded = added;
        loadData(); // 实时刷新 token 列表
      }

      let msg = `注册中 ${completed}/${total}（已添加 ${added}，失败 ${errors}）`;
      if (status === 'stopping') msg = `正在停止...（已添加 ${added}，失败 ${errors}）`;
      if (data.last_error) msg += `，最近错误：${data.last_error}`;
      updateAutoRegisterStatus(msg);
      return;
    }

    if (status === 'completed') {
      updateAutoRegisterStatus(`注册完成，新增 ${data.added || 0} 个`);
      showToast('注册完成', 'success');
      stopAutoRegisterPolling();
      const btn = document.getElementById('auto-register-btn');
      if (btn) btn.disabled = false;
      loadData();
      return;
    }

    if (status === 'stopped') {
      updateAutoRegisterStatus(`注册已停止（已添加 ${data.added || 0}，失败 ${data.errors || 0}）`);
      stopAutoRegisterPolling();
      const btn = document.getElementById('auto-register-btn');
      if (btn) btn.disabled = false;
      loadData();
      return;
    }

    if (status === 'error') {
      updateAutoRegisterStatus(`注册失败：${data.error || data.last_error || '未知错误'}`);
      showToast('注册失败', 'error');
      stopAutoRegisterPolling();
      const btn = document.getElementById('auto-register-btn');
      if (btn) btn.disabled = false;
    }
  } catch (e) {
    // ignore transient errors
  }
}



// Modal Logic
var currentEditIndex = -1;

function openEditModalByKey(tokenKey) {
  const idx = findTokenIndexByKey(tokenKey);
  if (idx < 0) return;
  openEditModal(idx);
}

function deleteTokenByKey(tokenKey) {
  const idx = findTokenIndexByKey(tokenKey);
  if (idx < 0) return;
  deleteToken(idx);
}

function openEditModal(index) {
  const modal = document.getElementById('edit-modal');
  if (!modal) return;

  currentEditIndex = index;

  if (index >= 0) {
    // Edit existing
    const item = flatTokens[index];
    document.getElementById('edit-token-display').value = item.token;
    document.getElementById('edit-original-token').value = item.token;
    document.getElementById('edit-original-pool').value = item.pool;
    document.getElementById('edit-pool').value = item.pool;
    document.getElementById('edit-quota').value = item.quota;
    document.getElementById('edit-note').value = item.note;
    document.querySelector('#edit-modal h3').innerText = '编辑 Token';
  } else {
    // New Token
    document.getElementById('edit-token-display').value = '';
    document.getElementById('edit-token-display').disabled = false;
    document.getElementById('edit-token-display').placeholder = 'sk-...';
    document.getElementById('edit-token-display').classList.remove('bg-gray-50', 'text-gray-500');

    document.getElementById('edit-original-token').value = '';
    document.getElementById('edit-original-pool').value = '';
    document.getElementById('edit-pool').value = 'ssoBasic';
    document.getElementById('edit-quota').value = 80;
    document.getElementById('edit-note').value = '';
    document.querySelector('#edit-modal h3').innerText = '添加 Token';
  }

  modal.classList.remove('hidden');
  requestAnimationFrame(() => {
    modal.classList.add('is-open');
  });
}

function closeEditModal() {
  const modal = document.getElementById('edit-modal');
  if (!modal) return;
  modal.classList.remove('is-open');
  setTimeout(() => {
    modal.classList.add('hidden');
    // reset styles for token input
    const input = document.getElementById('edit-token-display');
    if (input) {
      input.disabled = true;
      input.classList.add('bg-gray-50', 'text-gray-500');
    }
  }, 200);
}

async function saveEdit() {
  // Collect data
  let token;
  const newPool = document.getElementById('edit-pool').value.trim();
  const newQuota = parseInt(document.getElementById('edit-quota').value) || 0;
  const newNote = document.getElementById('edit-note').value.trim().slice(0, 50);

  if (currentEditIndex >= 0) {
    // Updating existing
    const item = flatTokens[currentEditIndex];
    token = item.token;

    // Update flatTokens first to reflect UI
    item.pool = newPool || 'ssoBasic';
    item.quota = newQuota;
    item.quota_known = true;
    item.token_type = poolToType(item.pool);
    item.note = newNote;
  } else {
    // Creating new
    token = normalizeSsoToken(document.getElementById('edit-token-display').value.trim());
    if (!token) return showToast('Token 不能为空', 'error');

    // Check if exists
    if (flatTokens.some(t => getTokenKey(t.token) === token)) {
      return showToast('Token 已存在', 'error');
    }

    flatTokens.push({
      token: token,
      pool: newPool || 'ssoBasic',
      quota: newQuota,
      quota_known: true,
      heavy_quota: -1,
      heavy_quota_known: false,
      token_type: poolToType(newPool || 'ssoBasic'),
      note: newNote,
      status: 'active', // default
      use_count: 0,
      _selected: false
    });
  }

  await syncToServer();
  closeEditModal();
  applyFilters();
  // Reload to ensure consistent state/grouping
  // Or simpler: just re-render but syncToServer does the hard work
  loadData();
}

async function deleteToken(index) {
  const ok = await confirmAction('确定要删除此 Token 吗？', { okText: '删除' });
  if (!ok) return;
  flatTokens.splice(index, 1);
  applyFilters();
  syncToServer().then(loadData);
}

function batchDelete() {
  startBatchDelete();
}

// Reconstruct object structure and save
async function syncToServer() {
  const newTokens = {};
  flatTokens.forEach(t => {
    if (!newTokens[t.pool]) newTokens[t.pool] = [];
    newTokens[t.pool].push({
      token: normalizeSsoToken(t.token),
      status: t.status,
      quota: t.quota,
      heavy_quota: t.heavy_quota,
      note: t.note,
      fail_count: t.fail_count,
      use_count: t.use_count || 0
    });
  });

  try {
    const res = await fetch('/api/v1/admin/tokens', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...buildAuthHeaders(apiKey)
      },
      body: JSON.stringify(newTokens)
    });
    const payload = await parseJsonSafely(res);
    if (!res.ok) {
      showToast(extractApiErrorMessage(payload, '保存失败'), 'error');
      return null;
    }

    const triggered = Number(payload?.nsfw_refresh?.triggered || 0);
    if (triggered > 0) {
      showToast(`已后台触发 ${triggered} 个 Token 的协议/年龄/NSFW 刷新`, 'info');
    }
    return payload;
  } catch (e) {
    showToast('保存错误: ' + e.message, 'error');
    return null;
  }
}

// Import Logic
function openImportModal() {
  const modal = document.getElementById('import-modal');
  if (!modal) return;
  modal.classList.remove('hidden');
  requestAnimationFrame(() => {
    modal.classList.add('is-open');
  });
}

function closeImportModal() {
  const modal = document.getElementById('import-modal');
  if (!modal) return;
  modal.classList.remove('is-open');
  setTimeout(() => {
    modal.classList.add('hidden');
    const input = document.getElementById('import-text');
    if (input) input.value = '';
  }, 200);
}

async function submitImport() {
  const pool = document.getElementById('import-pool').value.trim() || 'ssoBasic';
  const text = document.getElementById('import-text').value;
  const lines = text.split('\n');

  lines.forEach(line => {
    const t = normalizeSsoToken(line.trim());
    if (t && !flatTokens.some(ft => getTokenKey(ft.token) === t)) {
      flatTokens.push({
        token: t,
        pool: pool,
        status: 'active',
        quota: 80,
        quota_known: true,
        heavy_quota: -1,
        heavy_quota_known: false,
        token_type: poolToType(pool),
        note: '',
        use_count: 0,
        _selected: false
      });
    }
  });

  await syncToServer();
  closeImportModal();
  applyFilters();
  loadData();
}

// Export Logic
function exportTokens() {
  let content = "";
  flatTokens.forEach(t => content += t.token + "\n");
  if (!content) return showToast('列表为空', 'error');

  const blob = new Blob([content], { type: 'text/plain' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `tokens_export_${new Date().toISOString().slice(0, 10)}.txt`;
  document.body.appendChild(a);
  a.click();
  window.URL.revokeObjectURL(url);
  document.body.removeChild(a);
}

async function copyToClipboard(text, btn) {
  if (!text) return;
  try {
    await navigator.clipboard.writeText(text);
    const originalHtml = btn.innerHTML;
    btn.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
    btn.classList.remove('text-gray-400');
    btn.classList.add('text-green-500');
    setTimeout(() => {
      btn.innerHTML = originalHtml;
      btn.classList.add('text-gray-400');
      btn.classList.remove('text-green-500');
    }, 2000);
  } catch (err) {
    console.error('Copy failed', err);
  }
}

async function refreshStatus(token, btnEl) {
  const timed = withTimeoutSignal(TOKEN_REFRESH_TIMEOUT_MS);
  try {
    const btn = btnEl || null;
    if (btn) {
      btn.innerHTML = `<svg class="animate-spin" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 1 1-6.219-8.56"></path></svg>`;
    }

    const normalized = normalizeSsoToken(token);
    const res = await fetch('/api/v1/admin/tokens/refresh', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...buildAuthHeaders(apiKey)
      },
      body: JSON.stringify({ token: normalized }),
      signal: timed.signal,
    });

    const data = await parseJsonSafely(res);

    if (res.ok && data && data.status === 'success') {
      const results = data.results || {};
      const isSuccess = Boolean(results[normalized] ?? results[`sso=${normalized}`]);
      loadData();

      if (isSuccess) {
        showToast('刷新成功', 'success');
      } else {
        showToast('刷新失败', 'error');
      }
    } else {
      showToast(extractApiErrorMessage(data, '刷新失败'), 'error');
    }
  } catch (e) {
    console.error(e);
    showToast(`请求错误: ${normalizeRequestErrorMessage(e, '请求失败')}`, 'error');
  } finally {
    timed.done();
  }
}

async function refreshAllNsfw() {
  if ((activeRefreshJob || restoreActiveRefreshJob())) {
    showToast('当前已有刷新任务在执行', 'info');
    return;
  }
  const ok = await confirmAction(
    '将对全部 Token 执行：同意用户协议 + 设置年龄 + 开启 NSFW。任务会在后台持续执行，可切换到其他 Tab。是否继续？',
    { okText: '开始刷新' }
  );
  if (!ok) return;

  let estimatedTotal = flatTokens.length;
  if (!estimatedTotal) {
    await loadData();
    estimatedTotal = flatTokens.length;
  }
  if (!estimatedTotal) {
    showToast('未找到可刷新的 Token', 'warning');
    return;
  }

  logNsfwDebug('job-start', { estimatedTotal });
  const started = await startRefreshJob(
    '/api/v1/admin/tokens/nsfw/refresh/start',
    {
      all: true,
      enable_nsfw: true,
      retries: NSFW_REFRESH_JOB_RETRIES,
    },
    'token_nsfw_refresh'
  );
  if (!started) {
    logNsfwDebug('job-start-failed');
  }
}

async function startBatchRefresh() {
  if (isBatchProcessing || (activeRefreshJob || restoreActiveRefreshJob())) {
    showToast('当前有任务进行中', 'info');
    return;
  }

  const selected = flatTokens.filter(t => t._selected).map(t => normalizeSsoToken(t.token)).filter(Boolean);
  if (selected.length === 0) return showToast('未选择 Token', 'error');
  const ok = await confirmAction(`将刷新选中的 ${selected.length} 个 Token，任务会后台执行，可切换 Tab。是否继续？`, { okText: '开始刷新' });
  if (!ok) return;

  await startRefreshJob('/api/v1/admin/tokens/refresh/start', { tokens: selected }, 'token_refresh');
}

async function processBatchQueue() {
  if (!isBatchProcessing || isBatchPaused || currentBatchAction !== 'refresh') return;

  if (batchQueue.length === 0) {
    // Done
    finishBatchProcess();
    return;
  }

  // Take chunk
  const chunk = batchQueue.splice(0, BATCH_SIZE);
  const timed = withTimeoutSignal(TOKEN_REFRESH_TIMEOUT_MS);

  try {
    const res = await fetch('/api/v1/admin/tokens/refresh', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...buildAuthHeaders(apiKey)
      },
      body: JSON.stringify({ tokens: chunk }),
      signal: timed.signal,
    });

    if (res.ok) {
      batchProcessed += chunk.length;
    } else {
      const payload = await parseJsonSafely(res);
      showToast(`部分刷新失败: ${extractApiErrorMessage(payload, '请求失败')}`, 'error');
      batchProcessed += chunk.length;
    }
  } catch (e) {
    showToast(`网络请求错误: ${normalizeRequestErrorMessage(e, '请求失败')}`, 'error');
    batchProcessed += chunk.length;
  } finally {
    timed.done();
  }
  updateBatchProgress();

  // Recursive call for next batch
  // Small delay to allow UI updates and interactions
  if (!isBatchProcessing || isBatchPaused) return;
  setTimeout(() => {
    processBatchQueue();
  }, 80);
}

function toggleBatchPause() {
  if (!isBatchProcessing) return;
  isBatchPaused = !isBatchPaused;
  updateBatchProgress();
  if (!isBatchPaused) {
    if (currentBatchAction === 'refresh') {
      processBatchQueue();
    } else if (currentBatchAction === 'delete') {
      processDeleteQueue();
    }
  }
}

function stopBatchRefresh() {
  if (activeRefreshJob) {
    cancelActiveRefreshJob();
    return;
  }
  if (!isBatchProcessing) return;
  finishBatchProcess(true);
}

function finishBatchProcess(aborted = false) {
  const action = currentBatchAction;
  isBatchProcessing = false;
  isBatchPaused = false;
  batchQueue = [];
  currentBatchAction = null;

  updateBatchProgress();
  setActionButtonsState();
  updateSelectionState();
  loadData(); // Final data refresh

  if (aborted) {
    showToast(action === 'delete' ? '已终止删除' : '已终止刷新', 'info');
  } else {
    showToast(action === 'delete' ? '删除完成' : '刷新完成', 'success');
  }
}

async function batchUpdate() {
  startBatchRefresh();
}

function updateBatchProgress() {
  const container = document.getElementById('batch-progress');
  const text = document.getElementById('batch-progress-text');
  const pauseBtn = document.getElementById('btn-pause-action');
  const stopBtn = document.getElementById('btn-stop-action');
  if (!container || !text) return;
  if (activeRefreshJob) {
    if (lastRefreshJobSnapshot) {
      updateRefreshJobUi(lastRefreshJobSnapshot, { silent: true });
    }
    return;
  }
  if (!isBatchProcessing) {
    container.classList.add('hidden');
    if (pauseBtn) pauseBtn.classList.add('hidden');
    if (stopBtn) stopBtn.classList.add('hidden');
    return;
  }
  const pct = batchTotal ? Math.floor((batchProcessed / batchTotal) * 100) : 0;
  text.textContent = `${pct}%`;
  container.classList.remove('hidden');
  if (pauseBtn) {
    pauseBtn.textContent = isBatchPaused ? '继续' : '暂停';
    pauseBtn.classList.remove('hidden');
  }
  if (stopBtn) stopBtn.classList.remove('hidden');
}

function setActionButtonsState() {
  const selectedCount = flatTokens.filter(t => t._selected).length;
  const disabled = isBatchProcessing || Boolean(activeRefreshJob);
  const exportBtn = document.getElementById('btn-batch-export');
  const updateBtn = document.getElementById('btn-batch-update');
  const deleteBtn = document.getElementById('btn-batch-delete');
  const cleanupBtn = document.getElementById('btn-cleanup-failed-jobs');
  const cleanupStaleBtn = document.getElementById('btn-cleanup-stale-jobs');
  if (exportBtn) exportBtn.disabled = disabled || selectedCount === 0;
  if (updateBtn) updateBtn.disabled = disabled || selectedCount === 0;
  if (deleteBtn) deleteBtn.disabled = disabled || selectedCount === 0;
  if (cleanupBtn) cleanupBtn.disabled = isBatchProcessing;
  if (cleanupStaleBtn) cleanupStaleBtn.disabled = isBatchProcessing;
}

async function startBatchDelete() {
  if (isBatchProcessing) {
    showToast('当前有任务进行中', 'info');
    return;
  }
  const selected = flatTokens.filter(t => t._selected);
  if (selected.length === 0) return showToast('未选择 Token', 'error');
  const ok = await confirmAction(`确定要删除选中的 ${selected.length} 个 Token 吗？`, { okText: '删除' });
  if (!ok) return;

  isBatchProcessing = true;
  isBatchPaused = false;
  currentBatchAction = 'delete';
  batchQueue = selected.map(t => normalizeSsoToken(t.token));
  batchTotal = batchQueue.length;
  batchProcessed = 0;

  updateBatchProgress();
  setActionButtonsState();
  processDeleteQueue();
}

var confirmResolver = null;

function setupConfirmDialog() {
  const dialog = document.getElementById('confirm-dialog');
  if (!dialog) return;
  const okBtn = document.getElementById('confirm-ok');
  const cancelBtn = document.getElementById('confirm-cancel');
  dialog.addEventListener('click', (event) => {
    if (event.target === dialog) {
      closeConfirm(false);
    }
  });
  if (okBtn) okBtn.addEventListener('click', () => closeConfirm(true));
  if (cancelBtn) cancelBtn.addEventListener('click', () => closeConfirm(false));
}

function confirmAction(message, options = {}) {
  const dialog = document.getElementById('confirm-dialog');
  if (!dialog) {
    return Promise.resolve(false);
  }
  const messageEl = document.getElementById('confirm-message');
  const okBtn = document.getElementById('confirm-ok');
  const cancelBtn = document.getElementById('confirm-cancel');
  if (messageEl) messageEl.textContent = message;
  if (okBtn) okBtn.textContent = options.okText || '确定';
  if (cancelBtn) cancelBtn.textContent = options.cancelText || '取消';
  return new Promise(resolve => {
    confirmResolver = resolve;
    dialog.classList.remove('hidden');
    requestAnimationFrame(() => {
      dialog.classList.add('is-open');
    });
  });
}

function closeConfirm(ok) {
  const dialog = document.getElementById('confirm-dialog');
  if (!dialog) return;
  dialog.classList.remove('is-open');
  setTimeout(() => {
    dialog.classList.add('hidden');
    if (confirmResolver) {
      confirmResolver(ok);
      confirmResolver = null;
    }
  }, 200);
}

async function processDeleteQueue() {
  if (!isBatchProcessing || isBatchPaused || currentBatchAction !== 'delete') return;
  if (batchQueue.length === 0) {
    finishBatchProcess();
    return;
  }
  const chunk = batchQueue.splice(0, BATCH_SIZE);
  const toRemove = new Set(chunk);
  flatTokens = flatTokens.filter(t => !toRemove.has(normalizeSsoToken(t.token)));
  applyFilters();
  try {
    await syncToServer();
    batchProcessed += chunk.length;
  } catch (e) {
    showToast('删除失败', 'error');
    batchProcessed += chunk.length;
  }
  updateBatchProgress();
  if (!isBatchProcessing || isBatchPaused) return;
  setTimeout(() => {
    processDeleteQueue();
  }, 400);
}

function escapeHtml(text) {
  if (!text) return '';
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}



// init is triggered by header.js runPageInit for admin pages.
